@startuml




namespace publisher {
    class DomainError << (S,Aquamarine) >> {
        + StatusCode int
        + Err error
        + Retryable bool
        + Message string

        + Error() string

    }
    class MessageDTO << (S,Aquamarine) >> {
        + AlertID string
        + Title string
        + Responders string
        + Link string

    }
    interface Publisher  {
    }
    interface Sender  {
        + SendMessage( appcontext.Context,  MessageDTO) (string, error)

    }
    class domainError << (S,Aquamarine) >> {
        + StatusCode int
        + Description string
        + Retryable bool

    }
    class publisher << (S,Aquamarine) >> {
        + Sender Sender

        + SendMessage(ctx appcontext.Context, messageToSend MessageDTO) (string, error)

    }
}
"publisher.Sender" *-- "publisher.Publisher"

"publisher.Sender" <|-- "publisher.publisher"

namespace publishmanager {
    class AlertDTO << (S,Aquamarine) >> {
        + ID string
        + Title string
        + Responders string
        + CreatedAt int64

    }
    class DomainError << (S,Aquamarine) >> {
        + StatusCode int
        + Err error
        + Retryable bool
        + Message string

        + Error() string

    }
    class Input << (S,Aquamarine) >> {
        + Sender publisher.Sender
        + Repository Repository
        + Queuer Queuer
        + TimeToWaitingMinutes int

    }
    interface PublishManager  {
        + SendMessage( appcontext.Context,  From,  AlertDTO) error

    }
    class PublisherEntity << (S,Aquamarine) >> {
        + Message string
        + AlertId string
        + Responders string
        + Status string
        + CreatedAt time.Time
        + OpsgenieCreatedAt int64
        + UpdatedAt time.Time
        + TimeToWaitingMinutes int

        + IsExpired() bool
        + IsSent() bool
        + ToMessage() publisher.MessageDTO

    }
    class PublisherEntityStatusEnum << (S,Aquamarine) >> {
        + String() string

    }
    interface QueueWriter  {
        + Create( AlertDTO) error

    }
    interface Queuer  {
    }
    interface Repository  {
    }
    interface RepositoryReader  {
        + Find(applicationID string) (*PublisherEntity, error)

    }
    interface RepositoryWriter  {
        + Insert(applicationEntity PublisherEntity) (*PublisherEntity, error)

    }
    class domainError << (S,Aquamarine) >> {
        + StatusCode int
        + Description string
        + Retryable bool

    }
    class publishManager << (S,Aquamarine) >> {
        - publisher publisher.Publisher
        - repository Repository
        - queuer Queuer
        - timeToWaitingMinutes int

        - convertAlertToEntity(alert AlertDTO) (*PublisherEntity, error)
        - sendToQueueFactory(ctx appcontext.Context, from From, alert AlertDTO) <font color=blue>func</font>() error

        + SendMessage(ctx appcontext.Context, from From, alert AlertDTO) error

    }
    class publishmanager.From << (T, #FF7700) >>  {
    }
    class publishmanager.PublisherEntityStatusEnum << (T, #FF7700) >>  {
    }
    class repositoryMock << (S,Aquamarine) >> {
        + Insert(PublisherEntity PublisherEntity) (*PublisherEntity, error)
        + Delete(applicationID string) error
        + Upsert(PublisherEntity PublisherEntity) (*PublisherEntity, error)
        + Find(applicationID string) (*PublisherEntity, error)

    }
}
"publishmanager.QueueWriter" *-- "publishmanager.Queuer"
"publishmanager.RepositoryReader" *-- "publishmanager.Repository"
"publishmanager.RepositoryWriter" *-- "publishmanager.Repository"

"publishmanager.UseCases" <|-- "publishmanager.publishManager"
"publishmanager.RepositoryReader" <|-- "publishmanager.repositoryMock"
"publishmanager.RepositoryWriter" <|-- "publishmanager.repositoryMock"

namespace sqs {
    interface Consumer  {
        + Consume() ([]*QueueMessage, error)
        + ConsumeWithContext(ctx context.Context) ([]*QueueMessage, error)
        + PollingIntervalSeconds() int64

    }
    class Input << (S,Aquamarine) >> {
        + AwsRegion string
        + AwsProfile string
        + AwsEndpoint string
        + MaxNumberOfMessages int64
        + WaitTimeSeconds int64
        + MessageAttributeNames []string
        + Timeout time.Duration
        + URL string
        + PollingIntervalSeconds int64

    }
    class QueueMessage << (S,Aquamarine) >> {
        - receiptHandle string
        - queue *queue

        + Body string
        + Data <font color=blue>interface</font>{}

        + DeleteMessage() (string, error)
        + DeleteMessageWithContext(ctx context.Context) (string, error)

    }
    class queue << (S,Aquamarine) >> {
        - client *sqs.SQS
        - input Input
        - url string

        - sendMessageWithRetry(messageBody string, maxAttempts int, attempt int) (*sqs.SendMessageOutput, error)

        + Consume() ([]*QueueMessage, error)
        + ConsumeWithContext(ctx context.Context) ([]*QueueMessage, error)
        + PollingIntervalSeconds() int64
        + Create(msg publishmanager.AlertDTO) error

    }
}

"publishmanager.QueueWriter" <|-- "sqs.queue"
"sqs.Consumer" <|-- "sqs.queue"

namespace worker {
    interface Consumer  {
        + URL() string
        + Handler( appcontext.Context,  Input,  opsgenie.NotificationDTO) error
        + PollingIntervalSeconds() int64

    }
    class Input << (S,Aquamarine) >> {
        + Logger logwrapper.LoggerWrapper
        + PublishManager publishmanager.UseCases

    }
    class consumerWhoCreates << (S,Aquamarine) >> {
        + URL() string
        + Handler(ctx appcontext.Context, input Input, notificaiton opsgenie.NotificationDTO) error
        + PollingIntervalSeconds() int64

    }
}

"worker.Consumer" <|-- "worker.consumerWhoCreates"

"__builtin__.int" #.. "publishmanager.From"
"__builtin__.int" #.. "publishmanager.PublisherEntityStatusEnum"
"__builtin__.string" #.. "appcontext.ContextKey"
@enduml
